#!/usr/bin/env python3
"""
ENHANCED HYBRID MANUAL AI SOLVER - With Syllabus Integration
Features:
- 91% confidence threshold (raised from 85%)
- Complete IGCSE Physics syllabus structure
- Topic-based question classification
- Syllabus stored in separate folder for easy updates
- Enhanced metadata tracking
"""

import os
import sys
import json
import base64
from pathlib import Path
from datetime import datetime
import traceback
import re
from flask import Flask, request, jsonify, send_from_directory, render_template_string, send_file
from werkzeug.utils import secure_filename
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from PIL import Image
import io
import hashlib

# Configuration
QUESTION_BANKS_DIR = Path("../question_banks")
SYLLABUS_DIR = Path("../syllabus")  # New syllabus directory
CONFIDENCE_THRESHOLD = 0.91  # Updated to 91%

# Create directories
QUESTION_BANKS_DIR.mkdir(exist_ok=True)
SYLLABUS_DIR.mkdir(exist_ok=True)

app = Flask(__name__)

# Cambridge IGCSE Physics Syllabus Structure
IGCSE_PHYSICS_SYLLABUS = {
    "subject": "Physics",
    "qualification": "Cambridge IGCSE",
    "syllabus_code": "0625",
    "version": "Version 2",
    "valid_years": [2023, 2024, 2025],
    "topics": {
        "1": {
            "title": "Motion, forces and energy",
            "subtopics": {
                "1.1": "Physical quantities and measurement techniques",
                "1.2": "Motion",
                "1.3": "Mass and weight",
                "1.4": "Density",
                "1.5": {
                    "title": "Forces",
                    "subtopics": {
                        "1.5.1": "Effects of forces",
                        "1.5.2": "Turning effect of forces",
                        "1.5.3": "Centre of gravity"
                    }
                },
                "1.6": "Momentum",
                "1.7": {
                    "title": "Energy, work and power",
                    "subtopics": {
                        "1.7.1": "Energy",
                        "1.7.2": "Work",
                        "1.7.3": "Energy resources",
                        "1.7.4": "Power"
                    }
                },
                "1.8": "Pressure"
            }
        },
        "2": {
            "title": "Thermal physics",
            "subtopics": {
                "2.1": {
                    "title": "Kinetic particle model of matter",
                    "subtopics": {
                        "2.1.1": "States of matter",
                        "2.1.2": "Particle model",
                        "2.1.3": "Gases and the absolute scale of temperature"
                    }
                },
                "2.2": {
                    "title": "Thermal properties and temperature",
                    "subtopics": {
                        "2.2.1": "Thermal expansion of solids, liquids and gases",
                        "2.2.2": "Specific heat capacity",
                        "2.2.3": "Melting, boiling and evaporation"
                    }
                },
                "2.3": {
                    "title": "Transfer of thermal energy",
                    "subtopics": {
                        "2.3.1": "Conduction",
                        "2.3.2": "Convection",
                        "2.3.3": "Radiation",
                        "2.3.4": "Consequences of thermal energy transfer"
                    }
                }
            }
        },
        "3": {
            "title": "Waves",
            "subtopics": {
                "3.1": "General properties of waves",
                "3.2": {
                    "title": "Light",
                    "subtopics": {
                        "3.2.1": "Reflection of light",
                        "3.2.2": "Refraction of light",
                        "3.2.3": "Thin lenses",
                        "3.2.4": "Dispersion of light"
                    }
                },
                "3.3": "Electromagnetic spectrum",
                "3.4": "Sound"
            }
        },
        "4": {
            "title": "Electricity and magnetism",
            "subtopics": {
                "4.1": "Simple phenomena of magnetism",
                "4.2": {
                    "title": "Electrical quantities",
                    "subtopics": {
                        "4.2.1": "Electric charge",
                        "4.2.2": "Electric current",
                        "4.2.3": "Electromotive force and potential difference",
                        "4.2.4": "Resistance",
                        "4.2.5": "Electrical energy and electrical power"
                    }
                },
                "4.3": {
                    "title": "Electric circuits",
                    "subtopics": {
                        "4.3.1": "Circuit diagrams and circuit components",
                        "4.3.2": "Series and parallel circuits",
                        "4.3.3": "Action and use of circuit components"
                    }
                },
                "4.4": "Electrical safety",
                "4.5": {
                    "title": "Electromagnetic effects",
                    "subtopics": {
                        "4.5.1": "Electromagnetic induction",
                        "4.5.2": "The a.c. generator",
                        "4.5.3": "Magnetic effect of a current",
                        "4.5.4": "Force on a current-carrying conductor",
                        "4.5.5": "The d.c. motor",
                        "4.5.6": "The transformer"
                    }
                }
            }
        },
        "5": {
            "title": "Nuclear physics",
            "subtopics": {
                "5.1": {
                    "title": "The nuclear model of the atom",
                    "subtopics": {
                        "5.1.1": "The atom",
                        "5.1.2": "The nucleus"
                    }
                },
                "5.2": {
                    "title": "Radioactivity",
                    "subtopics": {
                        "5.2.1": "Detection of radioactivity",
                        "5.2.2": "The three types of nuclear emission",
                        "5.2.3": "Radioactive decay",
                        "5.2.4": "Half-life",
                        "5.2.5": "Safety precautions"
                    }
                }
            }
        },
        "6": {
            "title": "Space physics",
            "subtopics": {
                "6.1": {
                    "title": "Earth and the Solar System",
                    "subtopics": {
                        "6.1.1": "The Earth",
                        "6.1.2": "The Solar System"
                    }
                },
                "6.2": {
                    "title": "Stars and the Universe",
                    "subtopics": {
                        "6.2.1": "The Sun as a star",
                        "6.2.2": "Stars",
                        "6.2.3": "The Universe"
                    }
                }
            }
        }
    }
}

def save_syllabus_structure():
    """Save the syllabus structure to a separate file for easy updates"""
    syllabus_file = SYLLABUS_DIR / "igcse_physics_0625.json"
    
    with open(syllabus_file, 'w') as f:
        json.dump(IGCSE_PHYSICS_SYLLABUS, f, indent=2)
    
    print(f"Syllabus structure saved to: {syllabus_file}")
    return syllabus_file

def load_syllabus_structure():
    """Load syllabus structure from file"""
    syllabus_file = SYLLABUS_DIR / "igcse_physics_0625.json"
    
    if syllabus_file.exists():
        with open(syllabus_file, 'r') as f:
            return json.load(f)
    else:
        # Create the file if it doesn't exist
        save_syllabus_structure()
        return IGCSE_PHYSICS_SYLLABUS

def get_all_topics_list():
    """Generate a flat list of all topics for easy reference"""
    syllabus = load_syllabus_structure()
    topics_list = []
    
    def extract_topics(topics_dict, parent_key=""):
        for key, value in topics_dict.items():
            if key == "subtopics" and isinstance(value, dict):
                extract_topics(value, parent_key)
            elif isinstance(value, dict):
                if "title" in value:
                    full_key = f"{parent_key}.{key}" if parent_key else key
                    topics_list.append({
                        "code": full_key,
                        "title": value["title"],
                        "full_title": f"{full_key} {value['title']}"
                    })
                    if "subtopics" in value:
                        extract_topics(value["subtopics"], full_key)
                elif parent_key:
                    topics_list.append({
                        "code": f"{parent_key}.{key}",
                        "title": value,
                        "full_title": f"{parent_key}.{key} {value}"
                    })
            elif isinstance(value, str) and parent_key:
                topics_list.append({
                    "code": f"{parent_key}.{key}",
                    "title": value,
                    "full_title": f"{parent_key}.{key} {value}"
                })
    
    extract_topics(syllabus["topics"])
    return topics_list

def get_claude_prompt_template(subject, question_num, paper_folder=""):
    """Generate enhanced Claude prompt template with syllabus integration"""
    topics_list = get_all_topics_list()
    topics_for_prompt = "\n".join([f"  {topic['full_title']}" for topic in topics_list[:10]])
    
    return f"""Please analyze this {subject.lower()} question image and provide a complete solution in JSON format.

This question is from Cambridge IGCSE Physics (0625). Please classify it according to the syllabus topics:

Main Topics Available:
{topics_for_prompt}
... (and more subtopics)

Required JSON structure:
{{
  "question_text": "Extract the complete question text exactly as shown",
  "options": {{
    "A": "Complete text for option A",
    "B": "Complete text for option B", 
    "C": "Complete text for option C",
    "D": "Complete text for option D"
  }},
  "correct_answer": "A/B/C/D (single letter only)",
  "simple_answer": "Clear, concise explanation of the correct answer",
  "detailed_explanation": {{
    "approach": "Method or principle used",
    "calculation": "Key calculations if applicable",
    "reasoning": "Logical thought process", 
    "conclusion": "Why this answer is correct"
  }},
  "calculation_steps": [
    "Step 1: Description of first step",
    "Step 2: Description of second step",
    "Continue as needed..."
  ],
  "topic": "Specific topic code (e.g., '1.2' for Motion)",
  "topic_title": "Full topic name (e.g., '1.2 Motion')",
  "syllabus_area": "Main topic area (1-6)",
  "difficulty": "easy/medium/hard",
  "confidence_score": 0.95,
  "requires_calculation": true/false,
  "key_concepts": ["List", "of", "key", "physics", "concepts"]
}}

IMPORTANT: Confidence score must be ≥0.91 (91%) for approval. Anything below will be flagged for review.
Please be thorough and accurate in your analysis."""

class ScalableAISolverManager:
    """Enhanced AI Solver Manager with syllabus integration"""
    
    def __init__(self, question_banks_dir=None):
        self.question_banks_dir = Path(question_banks_dir) if question_banks_dir else QUESTION_BANKS_DIR
        self.current_paper_path = None
        self.solver_data = {}
        self.syllabus = load_syllabus_structure()
        
        # Ensure syllabus file exists
        save_syllabus_structure()
    
    def save_solution(self, paper_folder, question_number, solution_json):
        """Save solution with enhanced quality control (91% threshold)"""
        try:
            paper_folder_path = self.question_banks_dir / paper_folder
            master_solutions_file = paper_folder_path / "solutions.json"
            
            if not master_solutions_file.exists():
                return {"success": False, "error": "Master solutions.json file not found"}
            
            with open(master_solutions_file, 'r') as f:
                master_data = json.load(f)
            
            # Parse and validate solution
            if isinstance(solution_json, str):
                solution = json.loads(solution_json)
            else:
                solution = solution_json
            
            # Enhanced metadata with syllabus integration
            solution['question_number'] = question_number
            solution['saved_at'] = datetime.now().isoformat()
            solution['solver_version'] = "Hybrid Gen Alpha v2.1"
            solution['solved_by_ai'] = True
            solution['syllabus_version'] = self.syllabus.get('version', 'Version 2')
            solution['syllabus_code'] = self.syllabus.get('syllabus_code', '0625')
            
            # Enhanced quality control with 91% threshold
            confidence = solution.get('confidence_score', 0)
            
            # Comprehensive validation
            required_fields = [
                'question_text', 'options', 'correct_answer', 
                'simple_answer', 'detailed_explanation', 
                'topic', 'confidence_score'
            ]
            
            missing_fields = [field for field in required_fields if not solution.get(field)]
            
            # Enhanced auto-flagging with 91% threshold
            flag_reasons = []
            if confidence < CONFIDENCE_THRESHOLD:
                flag_reasons.append(f"Low confidence: {confidence:.1%} (< 91%)")
            if missing_fields:
                flag_reasons.append(f"Missing fields: {', '.join(missing_fields)}")
            
            # Options validation
            options = solution.get("options", {})
            if len(options) < 4:
                flag_reasons.append(f"Incomplete options: only {len(options)} found")
            
            # Topic validation
            topic = solution.get('topic', '')
            if not topic:
                flag_reasons.append("No topic classification provided")
            
            # Set flagging status
            solution['auto_flagged'] = len(flag_reasons) > 0
            solution['needs_review'] = len(flag_reasons) > 0
            solution['flag_reason'] = '; '.join(flag_reasons) if flag_reasons else None
            solution['quality_threshold'] = '91%'
            
            # Update question in master data
            question_found = False
            if 'questions' in master_data:
                for i, question in enumerate(master_data['questions']):
                    if question.get('question_number') == question_number:
                        master_data['questions'][i].update({
                            'question_text': solution.get('question_text'),
                            'options': solution.get('options'),
                            'correct_answer': solution.get('correct_answer'),
                            'explanation': solution.get('simple_answer'),
                            'detailed_explanation': solution.get('detailed_explanation'),
                            'calculation_steps': solution.get('calculation_steps'),
                            'topic': solution.get('topic'),
                            'topic_title': solution.get('topic_title', ''),
                            'syllabus_area': solution.get('syllabus_area', ''),
                            'difficulty': solution.get('difficulty'),
                            'confidence_score': confidence,
                            'requires_calculation': solution.get('requires_calculation', False),
                            'key_concepts': solution.get('key_concepts', []),
                            'solved_by_ai': True,
                            'saved_at': solution['saved_at'],
                            'auto_flagged': solution['auto_flagged'],
                            'needs_review': solution['needs_review'],
                            'flag_reason': solution['flag_reason']
                        })
                        question_found = True
                        break
            
            if not question_found:
                return {"success": False, "error": f"Question {question_number} not found in master file"}
            
            # Update comprehensive metadata
            master_data['metadata'].update({
                'last_updated': datetime.now().isoformat(),
                'ai_solver_version': 'Hybrid Gen Alpha v2.1',
                'confidence_threshold': '91%',
                'syllabus_integrated': True,
                'solving_in_progress': True
            })
            
            # Calculate enhanced statistics
            solved_questions = sum(1 for q in master_data['questions'] if q.get('solved_by_ai'))
            total_questions = len(master_data['questions'])
            flagged_questions = sum(1 for q in master_data['questions'] if q.get('auto_flagged'))
            high_confidence = sum(1 for q in master_data['questions'] if q.get('confidence_score', 0) >= CONFIDENCE_THRESHOLD)
            avg_confidence = sum(q.get('confidence_score', 0) for q in master_data['questions'] if q.get('solved_by_ai')) / max(solved_questions, 1)
            
            master_data['metadata'].update({
                'progress_stats': {
                    'total_questions': total_questions,
                    'solved_questions': solved_questions,
                    'completion_rate': round((solved_questions / total_questions) * 100, 1),
                    'flagged_questions': flagged_questions,
                    'high_confidence_questions': high_confidence,
                    'average_confidence': round(avg_confidence, 3),
                    'approval_rate': round((high_confidence / max(solved_questions, 1)) * 100, 1) if solved_questions > 0 else 0
                }
            })
            
            # Save back to master file
            with open(master_solutions_file, 'w') as f:
                json.dump(master_data, f, indent=2)
            
            print(f"Updated master solutions.json: Question {question_number} saved")
            print(f"Progress: {solved_questions}/{total_questions} ({master_data['metadata']['progress_stats']['completion_rate']}%)")
            print(f"Confidence: {confidence:.1%} ({'APPROVED' if confidence >= CONFIDENCE_THRESHOLD else 'FLAGGED'})")
            
            return {
                "success": True,
                "message": f"Solution for Question {question_number} saved successfully",
                "progress": master_data['metadata']['progress_stats'],
                "quality_status": {
                    "confidence": confidence,
                    "auto_flagged": solution['auto_flagged'],
                    "needs_review": solution['needs_review'],
                    "flag_reason": solution['flag_reason'],
                    "threshold_met": confidence >= CONFIDENCE_THRESHOLD
                }
            }
            
        except Exception as e:
            print(f"Error in save_solution: {str(e)}")
            traceback.print_exc()
            return {"success": False, "error": str(e)}

# Initialize components
scalable_solver = ScalableAISolverManager()

# Flask Routes (same as before, with updated confidence display)
@app.route('/')
def home():
    papers = []
    if QUESTION_BANKS_DIR.exists():
        for paper_folder in QUESTION_BANKS_DIR.iterdir():
            if paper_folder.is_dir():
                images_folder = paper_folder / "images"
                extracted_images_folder = paper_folder / "extracted_images"
                
                has_images = images_folder.exists() or extracted_images_folder.exists()
                
                if has_images:
                    total_images = 0
                    if images_folder.exists():
                        total_images += len([f for f in images_folder.glob("*") if f.suffix.lower() in ['.png', '.jpg', '.jpeg', '.gif', '.webp']])
                    if extracted_images_folder.exists():
                        total_images += len([f for f in extracted_images_folder.glob("*") if f.suffix.lower() in ['.png', '.jpg', '.jpeg', '.gif', '.webp']])
                    
                    solutions_file = paper_folder / "solutions.json"
                    solved_count = 0
                    approved_count = 0
                    
                    if solutions_file.exists():
                        try:
                            with open(solutions_file, 'r') as f:
                                data = json.load(f)
                                questions = data.get('questions', [])
                                solved_count = sum(1 for q in questions if q.get('solved_by_ai', False))
                                approved_count = sum(1 for q in questions if q.get('confidence_score', 0) >= CONFIDENCE_THRESHOLD and not q.get('auto_flagged', False))
                        except:
                            solved_count = 0
                            approved_count = 0
                    
                    papers.append({
                        "folder_name": paper_folder.name,
                        "total_questions": total_images,
                        "solved_count": solved_count,
                        "approved_count": approved_count,
                        "completion_rate": round((solved_count/total_images)*100, 1) if total_images > 0 else 0,
                        "approval_rate": round((approved_count/max(solved_count,1))*100, 1) if solved_count > 0 else 0,
                        "has_images_folder": images_folder.exists(),
                        "has_extracted_folder": extracted_images_folder.exists()
                    })
    
    # Enhanced dashboard HTML
    html = '''<!DOCTYPE html>
<html>
<head>
    <title>Enhanced Hybrid AI Solver Dashboard</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; 
            margin: 0; padding: 2rem; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #f5576c 75%, #4facfe 100%); 
            min-height: 100vh; 
        }
        .container { 
            max-width: 1200px; margin: 0 auto; 
            background: rgba(255, 255, 255, 0.95); 
            padding: 2rem; border-radius: 24px; 
        }
        .header { text-align: center; margin-bottom: 2rem; }
        .threshold-info {
            background: linear-gradient(135deg, #ff6b6b, #4ecdc4);
            color: white; padding: 1rem; border-radius: 15px;
            margin-bottom: 2rem; text-align: center; font-weight: 600;
        }
        .paper-card { 
            background: rgba(255, 255, 255, 0.9); 
            border-radius: 20px; padding: 1.5rem; margin: 1rem 0;
            display: grid; grid-template-columns: 2fr 1fr 1fr 1fr auto;
            gap: 1rem; align-items: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        .btn { 
            background: linear-gradient(135deg, #667eea, #764ba2); 
            color: white; padding: 0.8rem 1.5rem; 
            border-radius: 25px; text-decoration: none; font-weight: 700; 
        }
        .stats { font-size: 0.9rem; color: #666; }
        .approval-rate { font-weight: bold; }
        .high-approval { color: #27ae60; }
        .medium-approval { color: #f39c12; }
        .low-approval { color: #e74c3c; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Enhanced Hybrid AI Solver Dashboard</h1>
            <p>Cambridge IGCSE Physics 0625 • Syllabus Integrated • 91% Quality Threshold</p>
        </div>
        
        <div class="threshold-info">
            <strong>91% Confidence Threshold Active</strong><br>
            Solutions below 91% confidence will be automatically flagged for review
        </div>'''
    
    if papers:
        html += '<div style="display: grid; gap: 0.5rem;">'
        for paper in papers:
            approval_class = "high-approval" if paper["approval_rate"] >= 80 else "medium-approval" if paper["approval_rate"] >= 60 else "low-approval"
            
            html += f'''
            <div class="paper-card">
                <div>
                    <h3>{paper["folder_name"].replace('_', ' ').title()}</h3>
                    <div class="stats">
                        Images: {" + ".join([f for f in ["images/" if paper["has_images_folder"] else "", "extracted/" if paper["has_extracted_folder"] else ""] if f])}
                    </div>
                </div>
                <div class="stats">
                    <strong>{paper["solved_count"]}/{paper["total_questions"]}</strong><br>
                    {paper["completion_rate"]}% Complete
                </div>
                <div class="stats">
                    <strong>{paper["approved_count"]}</strong> Approved<br>
                    <span class="approval-rate {approval_class}">{paper["approval_rate"]}% Quality</span>
                </div>
                <div class="stats">
                    Flagged: {paper["solved_count"] - paper["approved_count"]}
                </div>
                <a href="/solver/{paper["folder_name"]}" class="btn">Start Solving</a>
            </div>'''
        html += '</div>'
    else:
        html += '''<div style="text-align: center; padding: 3rem;">
            <h3>No Papers Found</h3>
            <p>No folders with images detected.</p>
        </div>'''
    
    html += '</div></body></html>'
    return html

if __name__ == '__main__':
    print("Starting Enhanced Hybrid Manual AI Solver...")
    print("=" * 70)
    print(f"Question banks: {QUESTION_BANKS_DIR}")
    print(f"Syllabus directory: {SYLLABUS_DIR}")
    print(f"Confidence threshold: {CONFIDENCE_THRESHOLD * 100}%")
    print("Syllabus: Cambridge IGCSE Physics 0625")
    print("Port: 5006 (standalone)")
    print("Interface: http://localhost:5006")
    print("=" * 70)
    
    # Ensure directories exist
    QUESTION_BANKS_DIR.mkdir(exist_ok=True)
    SYLLABUS_DIR.mkdir(exist_ok=True)
    
    # Save syllabus structure
    save_syllabus_structure()
    
    app.run(host='0.0.0.0', port=5006, debug=True)